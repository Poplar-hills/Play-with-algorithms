package ShortestPath;

/*
* Bellman-ford 单源最短路径算法（Bellman-ford Single Source Shortest Path）
*
* - 概要
*   - 可以为含有负权边（negative weight edge）的图计算最短路径（Dijkstra 算法则不行）
*   - 相应的代价是复杂度是 O(EV)，大大高于 Dijkstra 算法。
*
* - 前提：
*   - 计算含有负权边的图的最短路径仍然依赖于松弛操作（relaxation）。
*   - 负权环：
*     - 如果一幅图中包含负权环（negative weight cycle），则该图中不存在最短路径，因为在环中每转一圈得到的总距离就越小。
*     - 例：3个顶点形成的负权环：0->1: 5, 1->2: -4, 2->0: -3；2个顶点形成的负权环：1->2: -4, 2->1: 1
*     - Bellman-ford 算法允许图中含有负权边，但不允许有负权环。
*
* - 原理：
*   - 在 Dijkstra 算法中，因为要求了图中没有负权边，因此当找到某个顶点的所有邻边中最短的那条时就可以认定该边一定在最短路径树上。
*     而当图中存在了负权边，则该假设就不再成立，需要通过松弛操作检查经过其他顶点到达该顶点的路径是否更短。
*   - 因为一次松弛操作，就是在找多添加一条边以后到达该顶点的更短路径，而一幅图中，从起始顶点到某一顶点最多会经过 V 个顶点（即经
*     过所有顶点）、有 V-1 条边，因此只需对每个顶点进行最多 V-1 次松弛操作即可找到到达该顶点的最短路径。
*
* */

public class BellmanFord {

}
