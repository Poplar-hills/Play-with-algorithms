package ShortestPath;

/*
* Bellman-ford 单源最短路径算法（Bellman-ford Single Source Shortest Path）
*
* - 概要
*   - 可以为含有负权边（negative weight edge）的图计算最短路径（Dijkstra 算法则不行）
*   - 相应的代价是复杂度是 O(EV)，大大高于 Dijkstra 算法。
*
* - 前提：
*   - 计算含有负权边的图的最短路径仍然依赖于松弛操作（relaxation）。
*   - 负权环：
*     - 如果一幅图中包含负权环（negative weight cycle），则该图中不存在最短路径，因为在环中每转一圈得到的总距离就越小。
*     - 例：3个顶点形成的负权环：0->1: 5, 1->2: -4, 2->0: -3；2个顶点形成的负权环：1->2: -4, 2->1: 1
*     - Bellman-ford 算法允许图中含有负权边，但不允许有负权环。
*
* - 算法原理：
*   - 在 Dijkstra 算法中，因为前提是图中没有负权边，因此当找到某个顶点的所有邻边中最短的那条时就可以认定该边一定在最短路径树上。
*     而当图中存在负权边时，该假设就不再成立，因为经过更多节点的路径可能总距离反而更短，因此需要检查是否存在这种路径。
*   - 检查的办法就是反复对图中的每条边进行松弛操作，使得起始顶点到每个顶点的距离逐步逼近其最短距离。
*   - 在一幅图中，从起始顶点到某一顶点最多会经过 V 个顶点（即经过所有顶点）、最多有 V-1 条边。而每次松弛都是对一条边进行的，因此
*     最多进行 V-1 次松弛操作即可找到到达某一顶点的最短路径。
* */

public class BellmanFord {

}
