package ShortestPath;

/*
* Dijkstra 单源最短路径算法（Dijkstra Single Source Shortest Path）
*
* - 概要
*   - Dijkstra 算法是应用最广、名气最大的针对有权图的最短路径算法。
*   - 用途：用于计算一幅带权图的最短路径树（即从起始顶点到图中所有其他顶点的最短路径）。
*   - 局限性：图中不能有负权边
*   - 时间复杂度：O(ElogV)
*
* - 运算过程动画演示 SEE：https://coding.imooc.com/lesson/71.html#mid=1495（3'30''）
*   看完演示中的例子后再来思考，若将 2->3 和 3->4 的权值分别改为 1.01 和 0.09，则结果是怎样的？（用手画来模拟运算过程最有效）
*
* - 运算过程：
*   1. 由起始顶点开始访问（顶点0）
*   2. 找到该顶点的所有邻边
*   3. 更新起始顶点到每条邻边上另一顶点的成本：
*        0  1  2  3  4           0  1  2  3  4
*        -------------    --->   -------------
*        0  -  -  -  -           0  5  2  6  -
*   4. 在未被访问的顶点（1、2、3、4）中，找到从起始顶点开始能以最低成本到达的那个顶点（访问顶点2），则到达该顶点的路径即在最短路径树上。
*   5. 进行 relaxation 操作，看看从该顶点到其他未被访问的节点是否有更低成本的路径，若有则更新对应成本：
*        0  1  2  3  4           0  1  2  3  4
*        -------------    --->   -------------
*        0  5  2  6  -           0  3  2  5  7
*   6. 至此完成一轮 Dijkstra 算法循环，跳到第4步继续循环（此时未被访问的顶点是1、3、4，成本最小的是路径是2->1，因此访问顶点1，
*      且路径2->1在最短路径树上）。
* */

public class Dijkstra {
}
