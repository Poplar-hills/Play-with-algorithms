package ShortestPath;

/*
* Dijkstra 单源最短路径算法（Dijkstra Single Source Shortest Path）
*
* - 概要
*   - Dijkstra 算法是应用最广、名气最大的针对有权图的最短路径算法。
*   - 用途：用于计算一幅带权图的最短路径树（即从起始顶点到图中所有其他顶点的最短路径）。
*   - 局限性：图中不能有负权边
*   - 时间复杂度：O(ElogV)
*
* - 运算过程动画演示 SEE：https://coding.imooc.com/lesson/71.html#mid=1495（3'30''）
*   看完演示中的例子后再来思考，若将 2->3 和 3->4 的权值分别改为 1.01 和 0.09，则结果是怎样的？（用手画来模拟运算过程最有效）
*
* - 运算过程：
*   1. 由起始顶点开始访问（顶点0）
*   2. 找到该顶点的所有邻边
*   3. 更新起始顶点到每条邻边上另一顶点的成本：
*        0  1  2  3  4           0  1  2  3  4
*        -------------    --->   -------------
*        0  -  -  -  -           0  5  2  6  -
*   4. 在未被访问的顶点（1、2、3、4）中，找到从起始顶点开始能以最低成本到达的那个顶点（访问顶点2），则到达该顶点的路径即在最短路径树上。
*   5. 进行 relaxation 操作，看看从该顶点到其他未被访问的节点的路径相较于之前是否成本更低，若是则更新对应顶点的成本：
*        0  1  2  3  4           0  1  2  3  4
*        -------------    --->   -------------
*        0  5  2  6  -           0  3  2  5  7
*   6. 至此完成一轮 Dijkstra 算法循环，跳到第4步继续循环（此时未被访问的顶点是1、3、4，成本最小的是路径是2->1，因此访问顶点1，
*      且路径2->1在最短路径树上）。
*
* - 算法所需数据结构：
*   从运算过程中可知，该算法主要做两件事：
*     1. 从未被访问的顶点中找出到达成本最小的那个节点，即从一个数组中找最小值。
*     2. 在发现有更低成本的路径后需要更新对应顶点成本，即更新数组中的元素。
*   - 最小索引堆能同时满足这两个需求（类似 Prim 算法里的需求）。
*
* - 复杂度分析：
*   正是因为要使用最小索引堆：
*     - 因此只需要开辟顶点个数大小的空间；
*     - 每次插入、更新操作都是 O(logV) 的复杂度；
*     - 另外在算法过程中要对所有边进行遍历，因此使得算法的整体复杂度为 O(ElogV) 级别。
* */

public class Dijkstra {
}
