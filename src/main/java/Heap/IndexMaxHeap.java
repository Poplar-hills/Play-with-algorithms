package Heap;

/*
* 索引堆（Index Heap）：
*
* - 我们之前实现的堆都是基于交换数组中的元素，这会带来两个问题：
*   1. 若元素的结构比较复杂（如超长字符串等）则交换起来性能开销很大。
*   2. 交换元素之后，元素索引的语义会丢失，因此很难再通过索引找到当初的元素。
*
*   例如：[15, 17, 19, 13, 22, 20] 中每个元素表示一个系统任务，元素索引表示的是系统进程的 id，比如：id = 0的任务的优先级
*   是15，id = 1的任务的优先级为17。当我们通过交换元素将这个数组转化成最大堆后，元素索引的语义被改变了，即元素索引不再表示某
*   个任务的系统进程 id，而表示的是该元素在堆中的位置，因此我们无法再通过系统进程 id 来取到该 id 最初对应的系统任务。这个问
*   题可以通过索引堆来解决。
*
* - 索引堆的原理：
*   - 在普通堆的基础上另外维护一组"堆索引"（即每个元素在堆中的索引），在生成堆的过程中交换的是不再是堆元素而是堆索引：
*         初始堆数据： [15, 17, 19, 13, 22, 20]    ----->    堆数据： [15, 17, 19, 13, 22, 20]
*         初始堆索引：  0   1   2   3   4   5                堆索引：  4   1   5   3   0   2
*   - 可见在生成完堆之后，堆中数据的位置（即数组索引）是不变的，变的只是堆索引，这样做：
*     1. 交换的只是索引，数据结构简单，不会有性能问题。
*     2.
* */

public class IndexMaxHeap {
}
