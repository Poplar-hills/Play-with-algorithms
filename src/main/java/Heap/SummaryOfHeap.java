package Heap;

/*
* 和堆相关的其他问题（SEE: https://coding.imooc.com/lesson/71.html#mid=1472（1'41''））
*
* - 问题：如何从 1,000,000 个元素中找出前100名？
*   - 更抽象一些的问法是：如何从 n 个元素中选出前 m 个元素？
*   - 如果使用排序算法是 O(nlogn)的复杂度，而使用堆则可以达到 O(nlogm) 的复杂度。
*   - 实现思路：建立一个元素个数 <= 100 的最小堆，将所有数据依次插入堆中，当堆达到 100 个元素上限之后，每次将最小元素移除出去后再
*     插入新元素。这样在所有元素都插入堆之后，堆里保留的就是前100个最大的元素了。
*
* - 基于堆的 n 路归并排序：
*   - 之前实现的是两路归并排序，而 n 路归并就是每层将元素分成 n 个子数组，然后再进行归并。在归并过程中每次就要比较 n 个元素的大小，
*     此时就可以将这 n 个元素放入一个最小堆中，每次从堆中 extract 出最小值，并且最小值出自哪个子数组就给哪个子数组添加一个新的元素，
*     并放入堆中继续处理。
*   - n 应该取多大是一个性能上的平衡：n 越大，则层数越少，但是每层的子数组个数就越多，即每次需要比较的元素个数就越多。
*   - 如果让 n = 数据集中的元素个数，即有 n 个子数组，且每个中都只有一个元素，则此时归并排序就就相当于退化成了堆排序。
*
* - 多叉堆：
* */

public class SummaryOfHeap {
    /* No content */
}
